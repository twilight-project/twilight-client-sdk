use diesel::prelude::*;
use dotenvy::dotenv;
use std::env;

// Note: schema.rs should be generated by diesel CLI
// For now, we'll use the table! macro directly
table! {
    accounts (address) {
        address -> Text,
        is_on_chain -> Bool,
        scalar -> Text,
        tag -> Text,
        value -> Integer,
    }
}

table! {
    orders (id) {
        id -> Integer,
        account_id -> Text,
        datetime -> Text,
        order_id -> Text,
        order_status -> Text,
        order_type -> Text,
        output -> Text,
        request_id -> Text,
        tx_hash -> Text,
        archived -> Bool,
    }
}

joinable!(orders -> accounts (account_id));
allow_tables_to_appear_in_same_query!(accounts, orders);

#[derive(Insertable, Queryable, Identifiable, AsChangeset)]
#[table_name = "accounts"]
pub struct Account {
    pub address: String,
    pub is_on_chain: bool,
    pub scalar: String,
    pub tag: String,
    pub value: i32,
}

#[derive(Insertable, Queryable, Identifiable, AsChangeset)]
#[table_name = "orders"]
pub struct Order {
    pub id: i32,
    pub account_id: String,
    pub datetime: String,
    pub order_id: String,
    pub order_status: String,
    pub order_type: String,
    pub output: String,
    pub request_id: String,
    pub tx_hash: String,
    pub archived: bool,
}

pub fn establish_connection() -> Result<PgConnection, Box<dyn std::error::Error>> {
    dotenv().ok();
    let database_url = env::var("DATABASE_URL")?;
    let connection = PgConnection::establish(&database_url)?;
    Ok(connection)
}

pub fn insert_account(conn: &PgConnection, account: Account) -> QueryResult<usize> {
    diesel::insert_into(accounts::table)
        .values(&account)
        .execute(conn)
}

pub fn delete_account(conn: &PgConnection, account_address: String) -> QueryResult<usize> {
    diesel::delete(accounts::table.find(account_address))
        .execute(conn)
}

pub fn insert_order(conn: &PgConnection, order: Order) -> QueryResult<usize> {
    diesel::insert_into(orders::table)
        .values(&order)
        .execute(conn)
}

pub fn delete_order(conn: &PgConnection, order_id: i32) -> QueryResult<usize> {
    diesel::delete(orders::table.find(order_id))
        .execute(conn)
}

pub fn replace_account(conn: &PgConnection, old_address: String, new_account: Account) -> QueryResult<()> {
    conn.transaction(|| {
        diesel::update(orders::table.filter(orders::account_id.eq(&old_address)))
            .set((orders::account_id.eq(&new_account.address), orders::archived.eq(true)))
            .execute(conn)?;

        diesel::delete(accounts::table.find(old_address)).execute(conn)?;

        diesel::insert_into(accounts::table).values(&new_account).execute(conn)?;

        Ok(())
    })
}

pub fn get_orders_by_account_id_all(conn: &PgConnection, account_id: String) -> QueryResult<Vec<Order>> {
    orders::table.filter(orders::account_id.eq(account_id)).load::<Order>(conn)
}

pub fn get_orders_by_account_id(conn: &PgConnection, account_id: String) -> QueryResult<Vec<Order>> {
    orders::table
        .filter(orders::account_id.eq(account_id))
        .filter(orders::archived.eq(false))
        .load::<Order>(conn)
}

pub fn get_account_by_address(conn: &PgConnection, address: String) -> QueryResult<Account> {
    accounts::table.find(address).first::<Account>(conn)
}